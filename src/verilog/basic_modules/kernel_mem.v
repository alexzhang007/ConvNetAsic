// -----------------------------------------------------------------------------
// This file exports the module `kernel_mem`, which stores the kernel weights.
// The module should be automatically generated by C program to fit the memory
// width and depth accordingly.
// -----------------------------------------------------------------------------

module kernel_mem #(
  parameter                     Kh = 3,           // convolutional kernel dimension
  parameter                     Kw = 3,
  parameter                     Nin = 3,          // input feature map no.
  parameter                     Nout = 3,         // output feature map no.
  parameter                     Pin = 2,          // input feature map parallelism
  parameter                     Pout = 1,         // output feature map parallelism
  parameter                     BIT_WIDTH = 8,    // bit width of the data path
  // unmodified inferred parameters
  parameter TILED_IN_PARALLEL   = ceil_div(Nin, Pin),
  parameter TILED_OUT_PARALLEL  = ceil_div(Nout, Pout),
  parameter MEM_DEPTH           = TILED_IN_PARALLEL * TILED_OUT_PARALLEL
) (
  input wire                    clk,              // system clock
  input wire  [Pin*Kh*Kw-1:0]   mem_en,           // memory enable (active low)
  input wire  [clog2(MEM_DEPTH)-1:0]
                                mem_addr,         // memory address

  output wire [Pout*Pin*Kh*Kw*BIT_WIDTH-1:0]
                                mem_data          // memory data
);

`include "functions.v"

localparam ROM_ADDR_WIDTH = clog2(MEM_DEPTH);

// Memory data output
wire [Pin*Kh*Kw*Pout*BIT_WIDTH-1:0] Q;
// generation iterator
genvar i, j, k, l;

// --------------------------------------------------------------------------
// Implementation notes: we instantiate Pin*Kh*Kw memory, each with width
// Pout*BIT_WIDTH. We can bypass the zero activation related memory access
// --------------------------------------------------------------------------
// Memory instantiation: automatically by tools (TODO)
`ifdef BEHAV_SIM
generate
  for (i = 0; i < Pin*Kh*Kw; i = i + 1) begin: rom_gen_i
    rom_full_ones # (
      .ROM_DEPTH          (MEM_DEPTH),
      .NUM_DATA           (Pout),
      .BIT_WIDTH          (BIT_WIDTH)
    ) rom_full_ones_inst (
      .clk                (clk),            // system clock
      .cen                (mem_en[i]),      // chip enable
      .A                  (mem_addr),       // rom read address
      .Q                  (Q[i*Pout*BIT_WIDTH+:Pout*BIT_WIDTH])
    );
  end
endgenerate
`else
generate
  for (i = 0; i < Pin*Kh*Kw; i = i + 1) begin: rom_gen_i
    rom_via_1024x8 rom_via_1024x8_inst (
      .CENY               (/* floating */),
      .AY                 (/* floating */),
      .Q                  (Q[i*Pout*BIT_WIDTH+:Pout*BIT_WIDTH]),
      .CLK                (clk),
      .CEN                (mem_en[i]),      // active low
      .A                  ({{(10-ROM_ADDR_WIDTH){1'b0}},
                          mem_addr}),       // 10-bit address (zero extension)
      .EMA                (3'b011),         // default value = 3
      .TEN                (1'b1),           // test mode enable (active low)
      .BEN                (1'b1),           // bypass enable (active low)
      .TCEN               (1'b1),           // test mode chip enable
      .TA                 (10'b0),          // test address
      .TQ                 (8'b0),           // test input
      .PGEN               (1'b0),           // power down enable (active high)
      .KEN                (1'b1)            // keeper enable (active low)
    );
  end
endgenerate
`endif

// Rearrange the data connection for the further convenient data processing
generate
  for (i = 0; i < Pout; i = i + 1) begin: rom_data_i
    for (j = 0; j < Pin; j = j + 1) begin: rom_data_j
      for (k = 0; k < Kh; k = k + 1) begin: rom_data_k
        for (l = 0; l < Kw; l = l + 1) begin: rom_data_l
          assign mem_data[(i*Pin*Kh*Kw+j*Kh*Kw+k*Kw+l)*BIT_WIDTH +: BIT_WIDTH] =
            Q[(j*Kh*Kw*Pout+k*Kw*Pout+l*Pout+i)*BIT_WIDTH +: BIT_WIDTH];
        end
      end
    end
  end
endgenerate

endmodule
